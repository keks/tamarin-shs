/*
How secure is secret handshake?
*/

theory SHS
begin

builtins: diffie-hellman, signing, symmetric-encryption

functions: mac/2, macv/3, ed2cv/1, h/1

equations: macv(mac(m, k), m, k) = true

rule Register_pk:
		[ Fr(~ltk) ]
	-->
		[ !Ltk($A, ~ltk), !Pk($A, <'g'^~ltk, pk(~ltk)>) ]


rule Get_pk:
		[ !Pk(A, pk) ]
	-->
		[ Out(pk) ]


rule Reveal_ltk:
		[ !Ltk(A, ltk) ]
	--[ LtkReveal(A) ]->
		[ Out(ltk) ]


// send client challenge
rule Client_sendChal:
		[ Fr(~eph)
		, !Ltk($A, ltkA)
		, !Pk($S, pkS)
		]
	-->
		[ Client_chalSent($A, $S, ltkA, ~eph, pkS, $appKey)
		, Out(<'g'^~eph, mac('g'^~eph, h($appKey))>)
		]


// send server challenge
rule Server_recvChal:
		let
			dhA = 'g'^X
			macKeyTx = h(<dhA^~eph, $appKey>)
			// macKey = h($appKey)<- this is the actual implementation
			msgMac = mac('g'^~eph, macKeyTx)
			macKeyRx = h($appKey)
			rxMacOk = macv(dhmac, dhA, macKeyRx)
		in
		[ Fr(~eph)
		, In(<dhA, dhmac>)
		]
	--[ True(rxMacOk) ]->
		[ Server_chalSent($S, ~eph, dhA, $appKey)
		, Out(<'g'^~eph, msgMac>)
		]


// send client auth
rule Client_recvChal:
		let
			dhS   = 'g'^X
			pkS   = <pkSdh, pkSpk>
			pkSdh = 'g'^Y
			eKey  = h(<<$appKey, dhS^eph>, pkSdh^eph>)
			sigd  = h(<<$appKey, pkS>, dhS^eph>)
			sig   = sign(sigd, ltkA)
			auth  = senc(<'g'^ltkA, sig>, eKey)
		in
		[	Client_chalSent(A, S, ltkA, eph, pkS, $appKey)
		,	In(<dhS, dhmac>)
		]
	--[ True(macv(dhmac, dhS, h(<dhS^eph, $appKey>))) // according to spec
	  , Reach() ]->
	//--[ True(macv(dhmac, dhS, h($appKey))) ]-> // actual implementation diverges from spec
		[ Client_authSent(A, S, dhS, eph, pkS, $appKey)
//		, Out(auth)
		]

/*

// server: recv client auth
rule Server_recvAuth:
		let	dKey = h(<<$appKey, fst(dhA)^eph>, fst(dhA)^ltk>)
				auth = sdec(encAuth, dKey)
				pkA  = fst(auth)
				rxsig  = snd(auth)
				rx   = h(<<$appKey, 'g'^ltk>,dhA^eph>)
				sk   = h(<<$appKey, dhA^eph>,<fst(pkA)^eph, dhA^ltk>>)
				sig  = sign(<<$appKey,auth>,fst(pkA)^ltk>, ltk)
		in
		[ Server_chalSent(S, eph, dhA, $appKey)
		, In(encAuth)
		, !Ltk(S, ltk)
		]
	--[ True(verify(rx, rxsig, snd(pkA)))
		,	SessKeyR(S, sk)
		]->
		[ Out(senc(sig, sk))
		]


// send client auth
rule Client_recvAuth:
		let	auth = sdec(encAuth, sk)
				pkS  = fst(auth)
				rxsig  = snd(auth)
				hmsg   = h(<<$appKey, pkS>,dhS^eph>)
				rx   = h(<<$appKey, hmsg>,h(fst(pkS)^ltk)>)
				sk   = h(<<$appKey, dhS^eph>,<dhS^ltk, pkS^eph>>)
		in
		[	Client_authSent(A, S, dhS, eph, pkS, $appKey)
		,	!Ltk(A, ltk)
		,	In(encAuth)
		]
	--[ SessKeyI(S, sk)
		]->
		[]

*/

axiom Eq:
	"All x y #i. Eq(x, y) @i ==> x = y"

axiom IsTrue:
	"All x #i. True(x) @i ==> x = true"

lemma Reachable:
  exists-trace
  "Ex #i. Reach()@i & not (Ex X #j. LtkReveal(X) @j)"

//explicit entity authentication
lemma Client_auth:
  " /* For all session keys 'k' setup by clients with a server 'S' */
    ( All S k #i.  SessKeyI(S, k) @ #i
       ==>
         /* there is a server that answered the request */
       ( (Ex #a. SessKeyR(S, k) @ a)
         /* or the adversary performed a long-term key reveal on 'S'
            before the key was setup. */
       | (Ex #r. LtkReveal(S) @ r & r < i)
       )
    )
  "
end
