/*
How secure is secret handshake?
*/

theory SHS
begin

builtins: diffie-hellman, signing, symmetric-encryption

functions: mac/2, h/1

rule Register_pk:
		[ Fr(~ltk) ]
	-->
		[ !Ltk($I, ~ltk)
		, !Pk($I, <'g'^~ltk, pk(~ltk)>)
		 ]

rule Get_pk:
		[ !Pk(I, pk) ]
	-->
		[ Out(pk) ]


rule Reveal_ltk:
		[ !Ltk(I, ltk) ]
	--[ LtkReveal(I) ]->
		[ Out(ltk) ]


// send client challenge
rule Initiator_sendChal:
	let
		pkI = <'g'^~ltkI, pk(~ltkI)>
	in
		[ Fr(~eph)
		, !Ltk($I, ~ltkI)
		, !Pk($R, pkR)
		]
	--[
		 Reach_InitiatorChal()
	]->
		[ Initiator_chalSent($I, $R, ~ltkI, ~eph, pkR, pkI, $appKey)
		, Out(<'g'^~eph, mac('g'^~eph, h($appKey))>)
		]

// send server challenge
rule Responder_recvChal:
		let
			dhI = 'g'^X
			macKeyTx = h(<dhI^~eph, $appKey>)
			// macKeyTx = h($appKey)<- this is the actual implementation
			msgMac = mac('g'^~eph, macKeyTx)
			macKeyRx = h($appKey)
		in
		[ Fr(~eph)
		, In(<dhI, mac(dhI, macKeyRx)>)
		]
	--[  Reach_ResponderChal()
	]->
		[ Responder_chalSent($R, ~eph, dhI, $appKey)
		, Out(<'g'^~eph, msgMac>)
		]

// send client auth
rule Initiator_recvChal:
		let
			dhR   = 'g'^X
			pkRdh = 'g'^~Y
			pkR   = <pkRdh, pkRed>
			ir    = dhR^~eph
			iR    = pkRdh^~eph
			sigd  = h(<$appKey, pkR, h(ir)>)
			sig   = sign(sigd, ltkI)
			iAuth  = <pkI,sig> //  == H
			eKey  = h(<$appKey, ir, iR>)
			iEncAuth  = senc(iAuth, eKey)
		in
		[	Initiator_chalSent(I, R, ltkI, ~eph, pkR, pkI, $appKey)
		,	In(<dhR, mac(dhR, h(<ir, $appKey>))>)
		//,	In(<dhR, mac(dhR, h($appKey))>) // actual implementation diverges from spec
		]
	--[ Reach_InitiatorAuth() ]->
		[ Initiator_authSent(I, R, ltkI, ~eph, dhR, pkR, $appKey, iAuth)
		, Out(iEncAuth)
		]


// server: recv client auth
rule Responder_recvAuth:
	let
		pkRdh   = 'g'^~eph
		pkRed   = pk(~eph)
		pkR     = <pkRdh, pkRed>
		dhI     = 'g'^X
		pkIdh   = 'g'^ltkI // this is ok due to pattern matching
		pkIed   = pk(ltkI) // but only for verifying stuff
		iR      = dhI^~ltkR
		ir      = dhI^~eph
		dKey    = h(<$appKey, ir, iR>)
		pkI     = <pkIdh, pkIed>
		Ir      = pkIdh^~eph 
		IR      = pkIdh^~ltkR
		rxSigd  = h(<$appKey, pkR, h(ir)>)
		rxSig   = sign(rxSigd, ltkI) // we only use this signatur in pattern matching, we don't send it
		auth    = <pkI, rxSig>
		encAuth = senc(auth, dKey)
		sk      = h(<$appKey, ir, Ir, iR>)
		sig     = sign(<$appKey, auth, h(ir)>, ~ltkR)
	in
	[
	  Responder_chalSent(R, ~eph, dhI, $appKey),
	  In(encAuth),
	  !Ltk(R, ~ltkR)
	]
	--[
	  SessKeyR(R, sk),
	  Reach_ResponderAuth()
	]->
	[
	  Out(senc(sig, sk))
	]

/*
		let
			dKey    = h(<$appKey, ir, iR>)
			iAuth   = sdec(iEncAuth, dKey)
			pkI     = fst(iAuth)
			rxsig   = snd(iAuth)
			pkIdh   = fst(pkI)
			pkIed   = snd(pkI)
			Ir      = pkIdh^~eph 
			rx      = h(<$appKey, pkR, h(ir)>)
			sk      = h(<$appKey, ir, Ir, iR>)
			sig     = sign(<$appKey, iAuth, Ir>, ~ltk)
		in
		[ Responder_chalSent(R, ~eph, dhI, $appKey)
		, In(iEncAuth)
		, !Ltk(R, ~ltk)
		, !Pk(R, pkR)
		]
	--[  True(verify(rx, rxsig, pkIed)),
		 SessKeyR(R, sk)
		, Reach_ResponderAuth()
		]->
		[  ]
*/

// client recv server auth
rule Initiator_recvAuth:
	let
		dhR     = 'g'^X
		pkRdh   = 'g'^ltkR
		pkRed   = pk(ltkR)
		pkR     = <pkRdh, pkRed>
		pkIdh   = 'g'^~eph
		pkIed   = pk(~eph)
		pkI     = <pkIdh, pkIed>
		ri      = dhR^~eph
		Ri      = pkRdh^~eph
		rI      = dhR^~ltk
		//hmsg    = h(<$appKey, pkR, ri>)
		rxSigd  = h(<$appKey, hmsg, h(ir)>)
		rxSig   = sign(rxSigd, ltkR) // we only use this signatur in pattern matching, we don't send it
		auth    = <pkR, rxSig>
		sk      = h(<$appKey, ri, rI, Ri>)
		encAuth = senc(auth, sk)
	in
	[
	  Initiator_authSent(I, R, ~ltk, ~eph, dhR, pkR, $appKey, hmsg),
	  In(encAuth)
	]
	--[
	  SessKeyI(R, sk),
	  Reach()
	]->
	[]


axiom Eq:
	"All x y #i. Eq(x, y) @i ==> x = y"

axiom IsTrue:
	"All x #i. True(x) @i ==> x = true"

lemma Sent_InitiatorChal:
	exists-trace
	"Ex #i. Reach_InitiatorChal()@i & not (Ex X #j. LtkReveal(X) @j)"

lemma Sent_ResponderChal:
	exists-trace
	"Ex #i. Reach_ResponderChal()@i & not (Ex X #j. LtkReveal(X) @j)"

lemma Sent_InitiatorAuth:
	exists-trace
	"Ex #i. Reach_InitiatorAuth()@i & not (Ex X #j. LtkReveal(X) @j)"

lemma Sent_ResponderAuth:
	exists-trace
	"Ex #i. Reach_ResponderAuth()@i & not (Ex X #j. LtkReveal(X) @j)"

lemma Reachable:
  exists-trace
  "Ex #i. Reach()@i & not (Ex X #j. LtkReveal(X) @j)"

//explicit entity authentication
lemma Initiator_auth:
  " /* For all session keys 'k' setup by clients with a server 'R' */
    ( All R k #i.  SessKeyI(R, k) @ #i
       ==>
         /* there is a server that answered the request */
       ( (Ex #a. SessKeyR(R, k) @ a)
         /* or the adversary performed a long-term key reveal on 'R'
            before the key was setup. */
       | (Ex #r. LtkReveal(R) @ r & r < i)
       )
    )
  "
end
