/*
How secure is secret handshake?
*/

theory SHS
begin

builtins: diffie-hellman, signing, symmetric-encryption

functions: mac/2, macv/3, h/1, ed2cv/1, cv2ed/1

equations: macv(mac(m, k), m, k) = true //, cv2ed('g'^ltk) = pk(ltk)

//ed2cv(pk(ltk)) = 'g'^ltk,

rule Register_pk:
		[ Fr(~ltk) ]
	-->
		[ !Ltk($A, ~ltk)
		, !Pk($A, <'g'^~ltk, pk(~ltk)>)
		 ]

//, !PkLookup('g'^~ltk, pk(ltk))


rule Get_pk:
		[ !Pk(A, pk) ]
	-->
		[ Out(pk) ]


rule Reveal_ltk:
		[ !Ltk(A, ltk) ]
	--[ LtkReveal(A) ]->
		[ Out(ltk) ]


// send client challenge
rule Client_sendChal:
		[ Fr(~eph)
		, !Ltk($A, ~ltkA)
		, !Pk($S, pkS)
		]
	--[
		 Reach_ClientChal()
	]->
		[ Client_chalSent($A, $S, ~ltkA, ~eph, pkS, $appKey)
		, Out(<'g'^~eph, mac('g'^~eph, h($appKey))>)
		]


// send server challenge
rule Server_recvChal:
		let
			dhA = 'g'^X
			macKeyTx = h(<dhA^~eph, $appKey>)
			// macKey = h($appKey)<- this is the actual implementation
			msgMac = mac('g'^~eph, macKeyTx)
			macKeyRx = h($appKey)
			rxMacOk = macv(dhmac, dhA, macKeyRx)
		in
		[ Fr(~eph)
		, In(<dhA, dhmac>)
		]
	--[  Reach_ServerChal()
		,True(rxMacOk) ]->
		[ Server_chalSent($S, ~eph, dhA, $appKey)
		, Out(<'g'^~eph, msgMac>)
		]


// send client auth
rule Client_recvChal:
		let
			dhS   = 'g'^X
			pkSdh = 'g'^~Y
			pkS   = <pkSdh, pkSed>
			eKey  = h(<$appKey, dhS^~eph, pkSdh^~eph>)
			sigd  = h(<$appKey, pkS, h(dhS^~eph)>)
			sig   = sign(sigd, ~ltkA)
			auth  = <pkA,sig>
			encAuth  = senc(auth, eKey)
		in
		[	Client_chalSent(A, S, ~ltkA, ~eph, pkS, $appKey)
		,	!Pk(A, pkA)
		,	In(<dhS, mac(dhS, h(<dhS^~eph, $appKey>))>)
		//,	In(<dhS, mac(dhS, h($appKey))>) // actual implementation diverges from spec
		]
	--[ Reach_ClientAuth() ]->
		[ Client_authSent(A, S, dhS, ~eph, pkS, $appKey, auth)
		, Out(encAuth)
		]


// server: recv client auth
rule Server_recvAuth:
		let
			dhA     = 'g'^X
			pkAdh   = 'g'^Y
			dKey    = h(<$appKey, dhA^~eph, dhA^~ltk>)
			pkA     = <pkAdh, pkAed>
			auth    = <pkA, rxsig>
			encAuth = senc(auth, dKey)
			rx      = h(<$appKey, pkS, h(dhA^~eph)>)
			sk      = h(<$appKey, dhA^~eph, pkAdh^~eph, dhA^~ltk>)
			sig     = sign(<$appKey, auth, pkAdh^~ltk>, ~ltk)
		in
		[ Server_chalSent(S, ~eph, dhA, $appKey)
		, In(encAuth)
		, !Ltk(S, ~ltk)
		, !Pk(S, pkS)
		]
	--[   True(verify(rx, rxsig, pkAed))
		, SessKeyR(S, sk)
		, Reach_ServerAuth()
		]->
		[ Out(senc(sig, sk))
		]


// send client auth
rule Client_recvAuth:
		let
			dhS     = 'g'^X
			pkSdh   = 'g'^Y
			pkS     = <pkSdh, pkSed>
			auth    = <pkS, rxsig>
			encAuth = senc(auth, sk)
			//hmsg    = h(<$appKey, pkS, dhS^~eph>)
			rx      = h(<$appKey, hmsg, h(pkSdh^~ltk)>)
			sk      = h(<$appKey, dhS^~eph, dhS^~ltk, pkSdh^~eph>)
		in
		[	Client_authSent(A, S, dhS, ~eph, pkS, $appKey, hmsg)
		,	!Ltk(A, ~ltk)
		,	In(encAuth)
		]
	--[   SessKeyI(S, sk)
		, True(verify(rx, rxsig, pkSed))
		, Reach()
		]->
		[]


axiom Eq:
	"All x y #i. Eq(x, y) @i ==> x = y"

axiom IsTrue:
	"All x #i. True(x) @i ==> x = true"

lemma Sent_ClientChal:
	exists-trace
	"Ex #i. Reach_ClientChal()@i & not (Ex X #j. LtkReveal(X) @j)"

lemma Sent_ServerChal:
	exists-trace
	"Ex #i. Reach_ServerChal()@i & not (Ex X #j. LtkReveal(X) @j)"

lemma Sent_ClientAuth:
	exists-trace
	"Ex #i. Reach_ClientAuth()@i & not (Ex X #j. LtkReveal(X) @j)"

lemma Sent_ServerAuth:
	exists-trace
	"Ex #i. Reach_ServerAuth()@i & not (Ex X #j. LtkReveal(X) @j)"

lemma Reachable:
  exists-trace
  "Ex #i. Reach()@i & not (Ex X #j. LtkReveal(X) @j)"

//explicit entity authentication
lemma Client_auth:
  " /* For all session keys 'k' setup by clients with a server 'S' */
    ( All S k #i.  SessKeyI(S, k) @ #i
       ==>
         /* there is a server that answered the request */
       ( (Ex #a. SessKeyR(S, k) @ a)
         /* or the adversary performed a long-term key reveal on 'S'
            before the key was setup. */
       | (Ex #r. LtkReveal(S) @ r & r < i)
       )
    )
  "
end
